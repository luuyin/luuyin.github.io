#!/usr/bin/env bash
set -Eeuo pipefail

# 使用方法：
#   bin/deploy -d main             # 从“当前分支的 HEAD”构建，然后发布到 main 分支
#   bin/deploy -d gh-pages         # 或发布到 gh-pages
DEPLOY_BRANCH="main"

while [[ $# -gt 0 ]]; do
  case "$1" in
    -d|--deploy) DEPLOY_BRANCH="$2"; shift ;;
    --verbose)   set -x ;;
    -h|--help)   echo "usage: bin/deploy [-d|--deploy DEPLOY_BRANCH]"; exit 0 ;;
    *)           echo "Unknown option $1"; exit 1 ;;
  esac
  shift
done

# 1) 保证工作区干净
if ! git diff-index --quiet HEAD --; then
  echo "⛔ 尚有未提交修改，请先 commit。"; exit 1
fi
if [[ -n "$(git ls-files --exclude-standard --others)" ]]; then
  echo "⛔ 尚有未跟踪文件，请先 commit 或清理："
  git ls-files --exclude-standard --others
  exit 1
fi

# 2) 用当前分支的 HEAD 作为构建源码（不会切换分支）
SRC_REF="$(git rev-parse --verify HEAD)"
echo "🚀 Build from: $(git rev-parse --abbrev-ref HEAD) @ $SRC_REF"
echo "🚀 Deploy to  : $DEPLOY_BRANCH"

# 3) 构建到临时目录
BUILD_DIR="$(mktemp -d)"
export JEKYLL_ENV=production
bundle exec jekyll build --source . --destination "$BUILD_DIR"

# 4) 用 worktree 检出部署分支到临时目录
PUB_DIR="$(mktemp -d)"
# 如果远端已有该分支，用远端作为起点；否则本地创建一个新的
if git ls-remote --exit-code --heads origin "$DEPLOY_BRANCH" >/dev/null 2>&1; then
  git worktree add -B "$DEPLOY_BRANCH" "$PUB_DIR" "origin/$DEPLOY_BRANCH"
else
  git worktree add -B "$DEPLOY_BRANCH" "$PUB_DIR"
fi

# 5) 同步静态文件到部署分支（删除多余文件）
rsync -a --delete --exclude '.git' "$BUILD_DIR"/ "$PUB_DIR"/

# 6) 阻止 Pages 再跑 Jekyll
touch "$PUB_DIR/.nojekyll"

# 7) 提交并推送
pushd "$PUB_DIR" >/dev/null
git add -A
git commit -m "Deploy $(date +'%F %T')" || true
git push origin "$DEPLOY_BRANCH"
popd >/dev/null

# 8) 清理
git worktree remove "$PUB_DIR" --force
rm -rf "$BUILD_DIR"

echo "✅ Done."
